<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="本文主要介绍Matrix的Resource部分，涉及Activity泄漏、Bitmap冗余对象的检测逻辑。">
<meta property="og:type" content="article">
<meta property="og:title" content="Matrix - ResourceCanary源码分析">
<meta property="og:url" content="https://hningoba.github.io/2020/06/23/Matrix-ResourceCanary实现分析/index.html">
<meta property="og:site_name" content="自律使人自由">
<meta property="og:description" content="本文主要介绍Matrix的Resource部分，涉及Activity泄漏、Bitmap冗余对象的检测逻辑。">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://raw.githubusercontent.com/hningoba/KnowledgeSummary/master/img/matrix_testactivity_leak_notification.png">
<meta property="og:image" content="https://developer.android.com/studio/images/profile/memory-profiler-callouts_2x.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hningoba/KnowledgeSummary/master/img/matrix_profiler_hprof.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hningoba/KnowledgeSummary/master/img/matrix_hprof_gcroots.png">
<meta property="og:image" content="https://hningoba.github.io/2020/06/img/matrix_hprof_record_structure.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hningoba/KnowledgeSummary/master/img/matrix_hprof_tag.png">
<meta property="og:updated_time" content="2020-06-23T13:35:34.120Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Matrix - ResourceCanary源码分析">
<meta name="twitter:description" content="本文主要介绍Matrix的Resource部分，涉及Activity泄漏、Bitmap冗余对象的检测逻辑。">
<meta name="twitter:image" content="https://raw.githubusercontent.com/hningoba/KnowledgeSummary/master/img/matrix_testactivity_leak_notification.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://hningoba.github.io/2020/06/23/Matrix-ResourceCanary实现分析/"/>





  <title>Matrix - ResourceCanary源码分析 | 自律使人自由</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">自律使人自由</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hningoba.github.io/2020/06/23/Matrix-ResourceCanary实现分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hningoba">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="自律使人自由">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Matrix - ResourceCanary源码分析</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-23T21:29:04+08:00">
                2020-06-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>本文主要介绍Matrix的Resource部分，涉及Activity泄漏、Bitmap冗余对象的检测逻辑。</p>
<a id="more"></a>
<p>再回顾下Matrix概览中提到的ResourceCanary模块的特点：基于 WeakReference 的特性和 <a href="https://github.com/square/haha" target="_blank" rel="noopener">Square Haha</a> 库开发的 Activity 泄漏和 Bitmap 重复创建检测工具。</p>
<p>主要特性如下：</p>
<ul>
<li>分离了检测和分析部分，便于在不打断自动化测试的前提下持续输出分析后的检测结果</li>
<li>对检测部分生成的 Hprof 文件进行了裁剪，移除了大部分无用数据，降低了传输 Hprof 文件的开销</li>
<li>增加了重复 Bitmap 对象检测，方便通过减少冗余 Bitmap 数量，降低内存消耗</li>
</ul>
<h3 id="如何判断Activity发生泄漏"><a href="#如何判断Activity发生泄漏" class="headerlink" title="如何判断Activity发生泄漏"></a>如何判断Activity发生泄漏</h3><p>判断Activity是否泄漏需要确定两个问题：</p>
<ul>
<li>如何在一个恰当的时机得知一个Activity已经结束了生命周期</li>
<li>如何判断一个Activity无法被GC机制回收</li>
</ul>
<p>这部分内容，Matrix借鉴了<a href="https://github.com/square/leakcanary" target="_blank" rel="noopener">LeakCanary</a>的做法，对LeakCanary比较熟悉的同学可以跳过。后续将针对这两个问题进行实现分析。</p>
<p>Demo中，<code>TestLeakActivity</code>被一个静态变量<code>testLeaks</code>持有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class TestLeakActivity extends Activity &#123;</span><br><span class="line">    private static Set&lt;Activity&gt; testLeaks = new HashSet&lt;&gt;();</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        testLeaks.add(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果是，退出页面时<code>TestLeakActivity</code>无法正常销毁，页面发生泄漏。</p>
<p>通过操作demo，可以看到如下IDE的输出log：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">V/Matrix.ActivityRefWatcher: triggering gc...</span><br><span class="line">V/Matrix.ActivityRefWatcher: gc was triggered.</span><br><span class="line">I/Matrix.ActivityRefWatcher: activity with key [MATRIX_RESCANARY_REFKEY_sample.tencent.matrix.resource.TestLeakActivity_2bd863cd6b8d4b78ae371fcc660c3b66] should be recycled but actually still exists in N times, wait for next detection to confirm.</span><br></pre></td></tr></table></figure>
<p>上面log意思是<code>TestLeakActivity</code>应该被回收但是仍然存在，即发生了泄漏。</p>
<h5 id="获取已销毁Activity的信息"><a href="#获取已销毁Activity的信息" class="headerlink" title="获取已销毁Activity的信息"></a>获取已销毁Activity的信息</h5><p>针对第一个问题“如何在一个恰当的时机得知一个Activity已经结束了生命周期”，我们看看Matrix怎么做的。</p>
<p>Matrix wiki中也提到的了解决方法：</p>
<ul>
<li>让所有Activity继承一个BaseActivity，然后在<code>BaseActivity.onDestroy()</code>方法中进行记录。</li>
<li>通过某种机制得知<code>Activity.onDestroy()</code>方法被调用，然后进行记录<ul>
<li>4.0以前可以通过反射替换<code>ActivityThread.mInstrumentation</code>对象为自己的代理，然后在代理中的<code>callActivityOnDestroy()</code>方法中记录。</li>
<li>4.0以后可以通过<code>Application.registerActivityLifecycleCallbacks()</code>方法注册一个回调对象，在回调对象的<code>onActivityDestroyed()</code>方法中记录。</li>
</ul>
</li>
</ul>
<p>显然第一种方法对业务侧入侵过重，不合适。第二种方法，考虑到4.0以前机器分布已经比较少了，Matrix直接使用<code>Application.registerActivityLifecycleCallbacks()</code>方式。</p>
<p>ResouceCanary中处理Activity泄漏问题的接口类是ResourcePlugin，看下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">com.tencent.matrix.resource.ResourcePlugin</span><br><span class="line"></span><br><span class="line">public class ResourcePlugin extends Plugin &#123;</span><br><span class="line">    private final ResourceConfig mConfig;</span><br><span class="line">    private ActivityRefWatcher mWatcher = null;</span><br><span class="line"></span><br><span class="line">    //加载配置</span><br><span class="line">    public ResourcePlugin(ResourceConfig config) &#123;</span><br><span class="line">        mConfig = config;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //处理泄漏误报</span><br><span class="line">    public static void activityLeakFixer(Application application) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    public ActivityRefWatcher getWatcher() &#123;</span><br><span class="line">        return mWatcher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void init(Application app, PluginListener listener) &#123;</span><br><span class="line">        super.init(app, listener);</span><br><span class="line">        ...</span><br><span class="line">        mWatcher = new ActivityRefWatcher(app, this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void start() &#123;</span><br><span class="line">        super.start();</span><br><span class="line">        ...</span><br><span class="line">        //启动ActivityRefWatcher，监听Activity生命周期</span><br><span class="line">        mWatcher.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码主要在组件启动时，启动了<code>ActivityRefWatcher</code>，看下<code>mWatcher.start()</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">com.tencent.matrix.resource.watcher.ActivityRefWatcher</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">    public void start() &#123;</span><br><span class="line">        stopDetect();</span><br><span class="line">        final Application app = mResourcePlugin.getApplication();</span><br><span class="line">        if (app != null) &#123;</span><br><span class="line">            // 注册Application.ActivityLifecycleCallbacks监听</span><br><span class="line">            app.registerActivityLifecycleCallbacks(mRemovedActivityMonitor);</span><br><span class="line">            // Activity泄漏检测任务调度，并根据DumpMode（可配置）选项对外输出泄漏提示</span><br><span class="line">            scheduleDetectProcedure();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上面代码主要做了两件事，注释中做了描述，其中Activity泄漏检测任务调度的逻辑后面会讲到。看下<code>mRemovedActivityMonitor</code>的逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">com.tencent.matrix.resource.watcher.ActivityRefWatcher</span><br><span class="line"></span><br><span class="line">private final Application.ActivityLifecycleCallbacks mRemovedActivityMonitor = new ActivityLifeCycleCallbacksAdapter() &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onActivityDestroyed(Activity activity) &#123;</span><br><span class="line">            pushDestroyedActivityInfo(activity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>当一个Activity销毁时，即<code>Activity.onDestroy()</code>执行时，<code>Application.ActivityLifecycleCallbacks.onActivityDestroyed()</code>就会被调用，看下<code>pushDestroyedActivityInfo()</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">com.tencent.matrix.resource.watcher.ActivityRefWatcher</span><br><span class="line"></span><br><span class="line">private void pushDestroyedActivityInfo(Activity activity) &#123;</span><br><span class="line">        final String activityName = activity.getClass().getName();</span><br><span class="line">        //泄漏Activity的上报排重</span><br><span class="line">        if (!mResourcePlugin.getConfig().getDetectDebugger() &amp;&amp; isPublished(activityName)) &#123;</span><br><span class="line">            MatrixLog.i(TAG, &quot;activity leak with name %s had published, just ignore&quot;, activityName);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //主要根据UUID和Activity信息组装key</span><br><span class="line">        final UUID uuid = UUID.randomUUID();</span><br><span class="line">        final StringBuilder keyBuilder = new StringBuilder();</span><br><span class="line">        keyBuilder.append(ACTIVITY_REFKEY_PREFIX).append(activityName)</span><br><span class="line">            .append(&apos;_&apos;).append(Long.toHexString(uuid.getMostSignificantBits())).append(Long.toHexString(uuid.getLeastSignificantBits()));</span><br><span class="line">        final String key = keyBuilder.toString();</span><br><span class="line">        final DestroyedActivityInfo destroyedActivityInfo</span><br><span class="line">            = new DestroyedActivityInfo(key, activity, activityName);</span><br><span class="line">        mDestroyedActivityInfos.add(destroyedActivityInfo);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上面代码主要做了两件事：</p>
<ul>
<li>Matrix通过<code>isPublished()</code>的逻辑上报改进点，已判断为泄漏的Activity，记录其类名，放到<code>FilePublisher.mPublishedMap</code>，后续再检测到该Activity，则排重，避免重复提示该Activity已泄漏</li>
<li>根据UUID和Activity信息组装key，将泄漏的Activity信息存放到<code>mDestroyedActivityInfos</code>，其中<code>DestroyedActivityInfo</code>内部使用一个WeakReference对象持有该Activity</li>
</ul>
<p><strong>总结：</strong></p>
<p>针对“如何在一个恰当的时机得知一个Activity已经结束了生命周期”，Matrix和LeakCanary的逻辑一样，通过<code>Application.registerActivityLifecycleCallbacks()</code>方法注册一个回调对象，在回调对象的<code>onActivityDestroyed()</code>方法中记录泄漏页面信息。</p>
<h5 id="如何判断Activity无法被GC回收"><a href="#如何判断Activity无法被GC回收" class="headerlink" title="如何判断Activity无法被GC回收"></a>如何判断Activity无法被GC回收</h5><p>针对前面提到的第二个问题，即“如何判断一个Activity无法被GC机制回收”，Matrix的做法是这样的：</p>
<p>首先通过上面《获取已销毁Activity的信息》部分获取到已经destroy的Activity，该Activity由WeakReference持有，然后主动触发一次“有效的GC”，如果该Activity能够被回收，则持有它的WeakReference会被置空，反之，如果持有它的WeakReference不为空，即GC无法回收这个已经销毁的Activity，认为该Activity发生了泄漏。</p>
<p>上面说的“有效的GC”，是因为JVM没有提供强制触发GC的API，像<code>System.gc()</code>或者<code>Runtime.getRuntime().gc()</code>都是建议系统进行GC，系统并不一定真正的触发GC。</p>
<p>针对这个问题，Matrix使用了“哨兵机制”，即增加了一个“哨兵对象”，该对象由WeakReference持有，执行<code>Runtime.getRuntime().gc()</code>后，如果该哨兵WeakReference被置空，则说明刚才的gc()调用，系统确实触发了一次GC操作。</p>
<p>看下这部分逻辑的代码，实现细节在<code>ActivityRefWatcher.scheduleDetectProcedure()</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">com.tencent.matrix.resource.watcher.ActivityRefWatcher</span><br><span class="line"></span><br><span class="line">private void scheduleDetectProcedure() &#123;</span><br><span class="line">        mDetectExecutor.executeInBackground(mScanDestroyedActivitiesTask);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>看下<code>mDetectExecutor.executeInBackground()</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">com.tencent.matrix.resource.watcher.RetryableTaskExecutor</span><br><span class="line"></span><br><span class="line">public void executeInBackground(final RetryableTask task) &#123;</span><br><span class="line">        postToBackgroundWithDelay(task, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">private void postToBackgroundWithDelay(final RetryableTask task, final int failedAttempts) &#123;</span><br><span class="line">        mBackgroundHandler.postDelayed(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                RetryableTask.Status status = task.execute();</span><br><span class="line">                //如果task.execute()返回RETRY，则进行延时重试</span><br><span class="line">                if (status == RetryableTask.Status.RETRY) &#123;</span><br><span class="line">                    postToBackgroundWithDelay(task, failedAttempts + 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, mDelayMillis);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上面代码就是在异步线程执行<code>mScanDestroyedActivitiesTask</code>，当该task返回值为<code>RetryableTask.Status.RETRY</code>时，则该task进行延时重试。看下该task内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">com.tencent.matrix.resource.watcher.ActivityRefWatcher</span><br><span class="line"></span><br><span class="line">private final RetryableTask mScanDestroyedActivitiesTask = new RetryableTask() &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Status execute() &#123;</span><br><span class="line">            //step1.没有destroy的Activity，则重试</span><br><span class="line">            // If destroyed activity list is empty, just wait to save power.</span><br><span class="line">            if (mDestroyedActivityInfos.isEmpty()) &#123;</span><br><span class="line">                MatrixLog.i(TAG, &quot;DestroyedActivityInfo isEmpty!&quot;);</span><br><span class="line">                return Status.RETRY;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            //step2.构建“哨兵”</span><br><span class="line">            final WeakReference&lt;Object&gt; sentinelRef = new WeakReference&lt;&gt;(new Object());</span><br><span class="line">            //step3.触发gc</span><br><span class="line">            triggerGc();</span><br><span class="line">            //“哨兵”没有被释放，说明step3并没有真正触发内存回收</span><br><span class="line">            if (sentinelRef.get() != null) &#123;</span><br><span class="line">                // System ignored our gc request, we will retry later.</span><br><span class="line">                MatrixLog.d(TAG, &quot;system ignore our gc request, wait for next detection.&quot;);</span><br><span class="line">                return Status.RETRY;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            final Iterator&lt;DestroyedActivityInfo&gt; infoIt = mDestroyedActivityInfos.iterator();</span><br><span class="line"></span><br><span class="line">            while (infoIt.hasNext()) &#123;</span><br><span class="line">                final DestroyedActivityInfo destroyedActivityInfo = infoIt.next();</span><br><span class="line">                </span><br><span class="line">                //step4.排重，避免重复提示Activity泄漏</span><br><span class="line">                if (!mResourcePlugin.getConfig().getDetectDebugger() &amp;&amp; isPublished(destroyedActivityInfo.mActivityName) &amp;&amp; mDumpHprofMode != ResourceConfig.DumpMode.SILENCE_DUMP) &#123;</span><br><span class="line">                    MatrixLog.v(TAG, &quot;activity with key [%s] was already published.&quot;, destroyedActivityInfo.mActivityName);</span><br><span class="line">                    infoIt.remove();</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                //step5.再次检测destroy的Activity是否被释放</span><br><span class="line">                if (destroyedActivityInfo.mActivityRef.get() == null) &#123;</span><br><span class="line">                    // The activity was recycled by a gc triggered outside.</span><br><span class="line">                    MatrixLog.v(TAG, &quot;activity with key [%s] was already recycled.&quot;, destroyedActivityInfo.mKey);</span><br><span class="line">                    infoIt.remove();</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                //step6.检测次数加1</span><br><span class="line">                ++destroyedActivityInfo.mDetectedCount;</span><br><span class="line"></span><br><span class="line">                //step7.检测次数小于最大重复检测次数，等下一次重试再安全check是否确实泄漏</span><br><span class="line">                if (destroyedActivityInfo.mDetectedCount &lt; mMaxRedetectTimes</span><br><span class="line">                    || !mResourcePlugin.getConfig().getDetectDebugger()) &#123;</span><br><span class="line">                    // Although the sentinel tell us the activity should have been recycled,</span><br><span class="line">                    // system may still ignore it, so try again until we reach max retry times.</span><br><span class="line">                    MatrixLog.i(TAG, &quot;activity with key [%s] should be recycled but actually still \n&quot;</span><br><span class="line">                            + &quot;exists in %s times, wait for next detection to confirm.&quot;,</span><br><span class="line">                        destroyedActivityInfo.mKey, destroyedActivityInfo.mDetectedCount);</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                MatrixLog.i(TAG, &quot;activity with key [%s] was suspected to be a leaked instance. mode[%s]&quot;, destroyedActivityInfo.mKey, mDumpHprofMode);</span><br><span class="line"></span><br><span class="line">                //step8.根据DumpMode执行不同的泄漏提示策略</span><br><span class="line">                //step8.1 SILENCE_DUMP模式下，以IssueActivity形式展示泄漏Activity信息</span><br><span class="line">                if (mDumpHprofMode == ResourceConfig.DumpMode.SILENCE_DUMP) &#123;</span><br><span class="line">                    if (mResourcePlugin != null &amp;&amp; !isPublished(destroyedActivityInfo.mActivityName)) &#123;</span><br><span class="line">                        final JSONObject resultJson = new JSONObject();</span><br><span class="line">                        try &#123;</span><br><span class="line">                            resultJson.put(SharePluginInfo.ISSUE_ACTIVITY_NAME, destroyedActivityInfo.mActivityName);</span><br><span class="line">                        &#125; catch (JSONException e) &#123;</span><br><span class="line">                            MatrixLog.printErrStackTrace(TAG, e, &quot;unexpected exception.&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line">                        mResourcePlugin.onDetectIssue(new Issue(resultJson));</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (null != activityLeakCallback) &#123;</span><br><span class="line">                        activityLeakCallback.onLeak(destroyedActivityInfo.mActivityName, destroyedActivityInfo.mKey);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; </span><br><span class="line">                //step8.2 AUTO_DUMP模式下，Toast提示并保存裁剪后hprof信息文件</span><br><span class="line">                else if (mDumpHprofMode == ResourceConfig.DumpMode.AUTO_DUMP) &#123;</span><br><span class="line">                    final File hprofFile = mHeapDumper.dumpHeap();</span><br><span class="line">                    if (hprofFile != null) &#123;</span><br><span class="line">                        markPublished(destroyedActivityInfo.mActivityName);</span><br><span class="line">                        final HeapDump heapDump = new HeapDump(hprofFile, destroyedActivityInfo.mKey, destroyedActivityInfo.mActivityName);</span><br><span class="line">                        mHeapDumpHandler.process(heapDump);</span><br><span class="line">                        infoIt.remove();</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        MatrixLog.i(TAG, &quot;heap dump for further analyzing activity with key [%s] was failed, just ignore.&quot;,</span><br><span class="line">                                destroyedActivityInfo.mKey);</span><br><span class="line">                        infoIt.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; </span><br><span class="line">                //step8.3 MANUAL_DUMP模式下，以通知形式提示泄漏信息</span><br><span class="line">                else if (mDumpHprofMode == ResourceConfig.DumpMode.MANUAL_DUMP) &#123;</span><br><span class="line">                    NotificationManager notificationManager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);</span><br><span class="line">                    String dumpingHeapContent = context.getString(R.string.resource_canary_leak_tip);</span><br><span class="line">                    String dumpingHeapTitle = destroyedActivityInfo.mActivityName;</span><br><span class="line">                    mContentIntent.putExtra(SharePluginInfo.ISSUE_ACTIVITY_NAME, destroyedActivityInfo.mActivityName);</span><br><span class="line">                    mContentIntent.putExtra(SharePluginInfo.ISSUE_REF_KEY, destroyedActivityInfo.mKey);</span><br><span class="line">                    PendingIntent pIntent = PendingIntent.getActivity(context, 0, mContentIntent,</span><br><span class="line">                            PendingIntent.FLAG_UPDATE_CURRENT);</span><br><span class="line">                    NotificationCompat.Builder builder = new NotificationCompat.Builder(context)</span><br><span class="line">                            .setContentTitle(dumpingHeapTitle)</span><br><span class="line">                            .setContentIntent(pIntent)</span><br><span class="line">                            .setContentText(dumpingHeapContent);</span><br><span class="line">                    Notification notification = buildNotification(context, builder);</span><br><span class="line">                    notificationManager.notify(NOTIFICATION_ID, notification);</span><br><span class="line"></span><br><span class="line">                    infoIt.remove();</span><br><span class="line">                    markPublished(destroyedActivityInfo.mActivityName);</span><br><span class="line">                    MatrixLog.i(TAG, &quot;show notification for notify activity leak. %s&quot;, destroyedActivityInfo.mActivityName);</span><br><span class="line">                &#125; </span><br><span class="line">                //step8.4 NO_DUMP模式下，以IssueActivity形式展示泄漏Activity信息</span><br><span class="line">                else &#123;</span><br><span class="line">                    // Lightweight mode, just report leaked activity name.</span><br><span class="line">                    MatrixLog.i(TAG, &quot;lightweight mode, just report leaked activity name.&quot;);</span><br><span class="line">                    markPublished(destroyedActivityInfo.mActivityName);</span><br><span class="line">                    if (mResourcePlugin != null) &#123;</span><br><span class="line">                        final JSONObject resultJson = new JSONObject();</span><br><span class="line">                        try &#123;</span><br><span class="line">                            resultJson.put(SharePluginInfo.ISSUE_ACTIVITY_NAME, destroyedActivityInfo.mActivityName);</span><br><span class="line">                        &#125; catch (JSONException e) &#123;</span><br><span class="line">                            MatrixLog.printErrStackTrace(TAG, e, &quot;unexpected exception.&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line">                        mResourcePlugin.onDetectIssue(new Issue(resultJson));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return Status.RETRY;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>上面这部分代码主要做了8件事，注释中都一一标明，本质上是利用“哨兵”机制和排重策略，准确的找到无法被GC回收的已销毁Activity，然后再根据外部可配置的DumpMode输出泄漏Activity的信息。</p>
<p>测试内存泄漏时，需要在<code>MatrixApplication</code>中ResourceCanary配置初始化过程中，将<code>ResourceConfig.Builder.setDetectDebuger()</code>传true才能看到具体的泄漏信息。比如我们把<code>DumpMode</code>改成<code>MANUAL_DUMP</code>，测试<code>TestLeakActivity</code>时，可以在通知栏看到如下信息，即<code>TestLeakActivity</code>发生了泄漏。</p>
<p><img src="https://raw.githubusercontent.com/hningoba/KnowledgeSummary/master/img/matrix_testactivity_leak_notification.png" style="zoom:65%;"></p>
<h3 id="Hprof信息使用"><a href="#Hprof信息使用" class="headerlink" title="Hprof信息使用"></a>Hprof信息使用</h3><p>hprof文件通常也叫堆转储文件，包含了Dump时刻内存中的所有对象的信息，包括类的描述，实例的数据和引用关系，线程的栈信息等。</p>
<h5 id="如何获取Hprof文件"><a href="#如何获取Hprof文件" class="headerlink" title="如何获取Hprof文件"></a>如何获取Hprof文件</h5><p>代码中可以使用<code>Debug.dumpHprofData(file)</code>方法获取Hprof文件。平时开发定位问题，可以直接用AndroidStudio中的Profiler获取hprof文件。官方文档<a href="https://developer.android.com/studio/profile/memory-profiler#save-hprof" target="_blank" rel="noopener">使用 Memory Profiler 查看 Java 堆和内存分配</a>比较详细的介绍了hprof的使用方法，具体可看官网。如果AS底部控制台没有Profiler选项，也可以通过AndroidStudio顶部Run菜单里面的profiler选项启动profiler。</p>
<p>Profiler目前已经是非常强大且易用的性能分析工具，可以分析CPU使用率、各种内存占用、网络使用、方法耗时等各种指标。笔者平视看代码，获取方法调用栈、分析方法耗时等，也经常使用该工具，比如之前分析Matrix-Trace源码分析文章时，通过Profiler的方法调用栈就比较容易的看到哪些方法是通过插桩实现的，方便快速熟悉陌生的项目，建议大家多学习使用该工具。</p>
<p>借用官网中提供的图片，下图中的“2”可用于获取hprof文件。平时开发过程中，Rocord一段App操作后，可以把操作后的堆栈信息用这种方式dump出来，后续便可使用AS导入hprof文件，方便分析。</p>
<p><img src="https://developer.android.com/studio/images/profile/memory-profiler-callouts_2x.png" style="zoom:65%;"></p>
<p>将本地Hprof本地文件导入到Profiler中：</p>
<p><img src="https://raw.githubusercontent.com/hningoba/KnowledgeSummary/master/img/matrix_profiler_hprof.png" style="zoom:65%;"></p>
<p>上图中各个列对应含义：</p>
<ul>
<li><strong>Allocations</strong>：堆中的分配数。</li>
<li><strong>Native Size</strong>：此对象类型使用的原生内存总量（以字节为单位）。只有在使用 Android 7.0 及更高版本时，才会看到此列。您会在此处看到采用 Java 分配的某些对象的内存，因为 Android 对某些框架类（如 <code>Bitmap</code>）使用原生内存。</li>
<li><strong>Shallow Size</strong>：此对象类型使用的 Java 内存总量（以字节为单位）。</li>
<li><strong>Retained Size</strong>：为此类的所有实例而保留的内存总大小（以字节为单位）。</li>
</ul>
<p>Profiler使用方法比较简单，这里不再展开。</p>
<h5 id="如何获取引用链"><a href="#如何获取引用链" class="headerlink" title="如何获取引用链"></a>如何获取引用链</h5><p>前面部分提到获取泄漏Activity的信息，对解决问题提供帮助还需要计算泄漏Activity对象到GCRoots的强引用链。GCRoots对象特点是，他们虽然不被其他生命周期更长的对象持有，但JVM特性导致这类对象不会被GC回收。因此，从这类对象出发，经过一系列强引用的对象也都无法被回收。这部分可以看看<a href="https://www.dynatrace.com/resources/ebooks/javabook/how-garbage-collection-works/" target="_blank" rel="noopener">这篇文章</a>。</p>
<p>GCRoots包括下面5类对象：</p>
<ul>
<li>静态成员，因为Java中的类，即被JVM system class loader加载的类无法卸载，也就无法被回收，典型的就是类的静态成员以及被静态成员持有的对象都是无法被GC的</li>
<li>局部变量或方法参数持有的对象</li>
<li>JNI Reference，包括JNILocalReference、JNIGlobalReference持有的对象</li>
<li>活动的Thread实例</li>
<li>synchronized关键字用到的对象</li>
</ul>
<p>如果某个Activity被泄漏，则必然存在从它到某个GC Root的强引用链。只要将这条强引用链找出来，开发者就能根据引用链上的对象找到合适的修改点快速解决问题。</p>
<p>Hprof文件格式可以参考<a href="http://hg.openjdk.java.net/jdk8/jdk8/jdk/raw-file/43cb25339b55/src/share/demo/jvmti/hprof/manual.html#mozTocId848088" target="_blank" rel="noopener">这份文档</a>Binary Dump Format一节，文档中GCRoots的Tag格式如下：</p>
<p><img src="https://raw.githubusercontent.com/hningoba/KnowledgeSummary/master/img/matrix_hprof_gcroots.png" style="zoom:65%;"></p>
<p>按照文档描述的格式将Hprof中的实例信息解析成描述引用关系的图结构后，套用经典的图搜索算法即可找到泄漏的Activity到GC Root的强引用链。这部分代码实现，老版的LeakCanary和Matrix都借鉴了<a href="https://github.com/square/haha" target="_blank" rel="noopener">HAHA库</a>的逻辑。目前这个Repo已经被标记为DEPRECATED，最新版的LeakCanary 2自己实现了名叫<a href="https://square.github.io/leakcanary/shark/" target="_blank" rel="noopener">Shark</a>的heap分析库，这个库使用Kotlin实现。</p>
<h5 id="Hprof文件分析"><a href="#Hprof文件分析" class="headerlink" title="Hprof文件分析"></a>Hprof文件分析</h5><p>Matrix ResourceCanary将检测Activity泄漏和分析泄漏对象的信息整个过程，分成检测和分析两个阶段。前者因为检测Activity泄漏包含很多系统概念，只能在端上做，但是分析阶段是一个处理hprof文件的过程，可以拆出来。拆出来的好处是：</p>
<ul>
<li>更新分析逻辑不再需要重新发客户端版本</li>
<li>Hprof文件留在了服务端，为人工分析提供了机会</li>
<li>如果跳过触发Dump Hprof，甚至可以把监测步骤在现网环境启用，以发现测试阶段难以触发的Activity泄漏</li>
</ul>
<p>前面检测阶段，会生成一个压缩包，内部包含一个hrof文件和一个<code>result.info</code>文件，后者包含的内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Resource Canary Result Infomation. THIS FILE IS IMPORTANT FOR THE ANALYZER !!</span><br><span class="line">sdkVersion=28</span><br><span class="line">manufacturer=Google</span><br><span class="line">hprofEntry=dump_54f653434ef64d31a0296e210e192472_shrink.hprof</span><br><span class="line">leakedActivityKey=MATRIX_RESCANARY_REFKEY_sample.tencent.matrix.resource.TestLeakActivity_98736b3660294fecacaa993a418563c8</span><br></pre></td></tr></table></figure>
<p>hprofEntry就是创建的hprof文件名，leakedActivityKey是leak activity的信息。</p>
<p>分析过程的代码在<code>matrix-resouce-canary-analyzer</code>这个module里面，入口方法是<code>CLIMain.main()</code>，下面来具体看下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">com.tencent.matrix.resource.analyzer.CLIMain</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        if (args.length == 0) &#123;</span><br><span class="line">            printUsage(System.out);</span><br><span class="line">            System.exit(ERROR_NEED_ARGUMENTS);</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 命令行参数解析</span><br><span class="line">            final CommandLine cmdline = new DefaultParser().parse(sOptions, args);</span><br><span class="line">            if (cmdline.hasOption(OPTION_HELP.mOption.getLongOpt())) &#123;</span><br><span class="line">                printUsage(System.out);</span><br><span class="line">                System.exit(ERROR_SUCCESS);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            parseArguments(cmdline);</span><br><span class="line"></span><br><span class="line">            // 分析hprof文件</span><br><span class="line">            doAnalyze();</span><br><span class="line"></span><br><span class="line">            System.exit(ERROR_SUCCESS);</span><br><span class="line">        &#125; catch (MissingOptionException e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上面代码先对命令行参数进行解析，入参配置可以参考下面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">args : &#123;</span><br><span class="line">&quot;-i&quot;, &quot;hprof_zip_file_path&quot;, </span><br><span class="line">&quot;-o&quot;, &quot;output_path&quot;, </span><br><span class="line">&quot;-co&quot;, &quot;true&quot;,</span><br><span class="line">&quot;-mb&quot;, &quot;100000&quot;&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>-i：检测阶段生成的hprof压缩包文件路径，该参数必选</li>
<li>-o：分析结果输出文件路径，该参数必选</li>
<li>-co：是否将分析结果输出文件做成压缩文件，该参数可选</li>
<li>-mb：触发bitmap泄漏警告的最小尺寸，默认阈值时5000，该参数可选</li>
</ul>
<p>这几个参数的含义可以参考<code>CLIMain.AnalyzerOptions</code>。</p>
<p>参数解析完后，执行<code>doAnalyze()</code>进行具体分析逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">com.tencent.matrix.resource.analyzer.CLIMain</span><br><span class="line"></span><br><span class="line">private static void doAnalyze() throws IOException &#123;</span><br><span class="line">        // 解析检测阶段生成的result.info文件，并将信息保存到resultInfoMap</span><br><span class="line">        ZipFile zf = null;</span><br><span class="line">        BufferedReader br = null;</span><br><span class="line">        File tempHprofFile = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            zf = new ZipFile(mInputFile);</span><br><span class="line">            final ZipEntry canaryResultInfoEntry = new ZipEntry(&quot;result.info&quot;);</span><br><span class="line">            final Map&lt;String, String&gt; resultInfoMap = new HashMap&lt;&gt;();</span><br><span class="line">            br = new BufferedReader(new InputStreamReader(zf.getInputStream(canaryResultInfoEntry)));</span><br><span class="line">            String confLine = null;</span><br><span class="line">            while ((confLine = br.readLine()) != null) &#123;</span><br><span class="line">                if (confLine.startsWith(&quot;#&quot;)) &#123;</span><br><span class="line">                    // Skip comment.</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                final String[] kvPair = confLine.split(&quot;\\s*=\\s*&quot;);</span><br><span class="line">                if (kvPair.length != 2) &#123;</span><br><span class="line">                    // Skip bad config line.</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                final String key = kvPair[0].trim();</span><br><span class="line">                final String value = kvPair[1].trim();</span><br><span class="line">                resultInfoMap.put(key, value);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 从result.info中解析出sdkVersion、manufacturer、hprofEntry、leakedActivityKey</span><br><span class="line">            final String sdkVersionStr = resultInfoMap.get(&quot;sdkVersion&quot;);</span><br><span class="line">            if (sdkVersionStr == null) &#123;</span><br><span class="line">                throw new IllegalStateException(&quot;sdkVersion is absent in result.info.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            final int sdkVersion = Integer.parseInt(sdkVersionStr);</span><br><span class="line"></span><br><span class="line">            final String manufacturer = resultInfoMap.get(&quot;manufacturer&quot;);</span><br><span class="line">            if (manufacturer == null) &#123;</span><br><span class="line">                throw new IllegalStateException(&quot;manufacturer is absent in result.info.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            final String hprofEntryName = resultInfoMap.get(&quot;hprofEntry&quot;);</span><br><span class="line">            if (hprofEntryName == null) &#123;</span><br><span class="line">                throw new IllegalStateException(&quot;hprofEntry is absent in result.info.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            final ZipEntry hprofEntry = new ZipEntry(hprofEntryName);</span><br><span class="line"></span><br><span class="line">            final String leakedActivityKey = resultInfoMap.get(&quot;leakedActivityKey&quot;);</span><br><span class="line">            if (leakedActivityKey == null) &#123;</span><br><span class="line">                throw new IllegalStateException(&quot;leakedActivityKey is absent in result.info.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 将hprof信息复制到临时文件中</span><br><span class="line">            // We would extract hprof entry into a temporary file.</span><br><span class="line">            tempHprofFile = new File(new File(&quot;&quot;).getAbsoluteFile(), &quot;temp_&quot; + System.currentTimeMillis() + &quot;.hprof&quot;);</span><br><span class="line">            StreamUtil.extractZipEntry(zf, hprofEntry, tempHprofFile);</span><br><span class="line"></span><br><span class="line">            // 解析extra.info</span><br><span class="line">            // Parse extra info if exists.</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            // 执行分析逻辑</span><br><span class="line">            // Then do analyzing works and output into directory or zip according to the option. Besides,</span><br><span class="line">            // store extra info into the result json by the way.</span><br><span class="line">            analyzeAndStoreResult(tempHprofFile, sdkVersion, manufacturer, leakedActivityKey, extraInfo);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (tempHprofFile != null) &#123;</span><br><span class="line">                tempHprofFile.delete();</span><br><span class="line">            &#125;</span><br><span class="line">            StreamUtil.closeQuietly(br);</span><br><span class="line">            StreamUtil.closeQuietly(zf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上面代码主要是解析检测阶段生成的result.info文件的数据，后续通过<code>analyzeAndStoreResult()</code>进行分析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">com.tencent.matrix.resource.analyzer.CLIMain</span><br><span class="line"></span><br><span class="line">private static void analyzeAndStoreResult(File hprofFile, int sdkVersion, String manufacturer, String leakedActivityKey, JSONObject extraInfo) throws IOException &#123;</span><br><span class="line">        </span><br><span class="line">        //使用HAHA库解析Hprof</span><br><span class="line">        final HeapSnapshot heapSnapshot = new HeapSnapshot(hprofFile);</span><br><span class="line">        final ExcludedRefs excludedRefs = AndroidExcludedRefs.createAppDefaults(sdkVersion, manufacturer).build();</span><br><span class="line">        </span><br><span class="line">        // 执行获取最短强引用链逻辑</span><br><span class="line">        final ActivityLeakResult activityLeakResult</span><br><span class="line">                = new ActivityLeakAnalyzer(leakedActivityKey, excludedRefs).analyze(heapSnapshot);</span><br><span class="line"></span><br><span class="line">        // SDK小于26，分析冗余Bitmap</span><br><span class="line">        DuplicatedBitmapResult duplicatedBmpResult = DuplicatedBitmapResult.noDuplicatedBitmap(0);</span><br><span class="line">        if (sdkVersion &lt; 26) &#123;</span><br><span class="line">            final ExcludedBmps excludedBmps = AndroidExcludedBmpRefs.createDefaults().build();</span><br><span class="line">            duplicatedBmpResult = new DuplicatedBitmapAnalyzer(mMinBmpLeakSize, excludedBmps).analyze(heapSnapshot);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.err.println(&quot;\n ! SDK version of target device is larger or equal to 26, &quot;</span><br><span class="line">                    + &quot;which is not supported by DuplicatedBitmapAnalyzer.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        final String resultJsonName = &quot;result.json&quot;;</span><br><span class="line">        final String bufferContentsRootDirName = &quot;buffer_contents&quot;;</span><br><span class="line">        final String extralInfoKey = &quot;extraInfo&quot;;</span><br><span class="line">        </span><br><span class="line">        // 将解析结果转换成zip压缩包格式</span><br><span class="line">        if (mCompressOutput) &#123;</span><br><span class="line">            ZipOutputStream zos = null;</span><br><span class="line">            try &#123;</span><br><span class="line">                zos = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(mOutputFile)));</span><br><span class="line">                final ZipEntry analyzeResultEntry = new ZipEntry(resultJsonName);</span><br><span class="line">                zos.putNextEntry(analyzeResultEntry);</span><br><span class="line">                try &#123;</span><br><span class="line">                    final PrintWriter pw = new PrintWriter(zos);</span><br><span class="line">                    final JSONObject resultJson = new JSONObject();</span><br><span class="line">                    final JSONObject activityLeakResultJson = new JSONObject();</span><br><span class="line">                    activityLeakResult.encodeToJSON(activityLeakResultJson);</span><br><span class="line">                    final JSONObject duplicatedBmpResultJson = new JSONObject();</span><br><span class="line">                    duplicatedBmpResult.encodeToJSON(duplicatedBmpResultJson);</span><br><span class="line"></span><br><span class="line">                    resultJson.put(&quot;activityLeakResult&quot;, activityLeakResultJson)</span><br><span class="line">                              .put(&quot;duplicatedBitmapResult&quot;, duplicatedBmpResultJson);</span><br><span class="line"></span><br><span class="line">                    if (extraInfo != null &amp;&amp; extraInfo.length() &gt; 0) &#123;</span><br><span class="line">                        resultJson.put(extralInfoKey, extraInfo);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    pw.println(resultJson.toString());</span><br><span class="line">                    pw.flush();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        zos.closeEntry();</span><br><span class="line">                    &#125; catch (Throwable ignored) &#123;</span><br><span class="line">                        // Ignored.</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // Store bitmap buffer.</span><br><span class="line">                final List&lt;DuplicatedBitmapEntry&gt; duplicatedBmpEntries = duplicatedBmpResult.getDuplicatedBitmapEntries();</span><br><span class="line">                final int duplicatedBmpEntryCount = duplicatedBmpEntries.size();</span><br><span class="line">                for (int i = 0; i &lt; duplicatedBmpEntryCount; ++i) &#123;</span><br><span class="line">                    final DuplicatedBitmapEntry entry = duplicatedBmpEntries.get(i);</span><br><span class="line">                    final BufferedImage img = BitmapDecoder.getBitmap(</span><br><span class="line">                            new HprofBitmapProvider(entry.getBuffer(), entry.getWidth(), entry.getHeight()));</span><br><span class="line">                    // Since bmp format is not compatible with alpha channel, we export buffer as png instead.</span><br><span class="line">                    final String pngName = bufferContentsRootDirName + &quot;/&quot; + entry.getBufferHash() + &quot;.png&quot;;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        zos.putNextEntry(new ZipEntry(pngName));</span><br><span class="line">                        ImageIO.write(img, &quot;png&quot;, zos);</span><br><span class="line">                        zos.flush();</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            zos.closeEntry();</span><br><span class="line">                        &#125; catch (Throwable ignored) &#123;</span><br><span class="line">                            // Ignored.</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                StreamUtil.closeQuietly(zos);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上面先在<code>HeapSnapshot(File hprofFile)</code>内部使用HAHA库解析Hprof文件，再通过<code>ActivityLeakAnalyzer().analyze()</code>分析泄漏Activity的最短强引用链。</p>
<h5 id="Hprof文件格式说明"><a href="#Hprof文件格式说明" class="headerlink" title="Hprof文件格式说明"></a>Hprof文件格式说明</h5><p>在介绍haha库如何解析Hprof之前，先简单介绍下Hprof文件的结构。</p>
<p>Hprof文件主要由一系列的record组成，每一个record的内容结构如下：</p>
<p><img src="../../img/matrix_hprof_record_structure.png" alt="image-20200524205227221"></p>
<p>每一个record包含四部分内容：</p>
<ul>
<li>TAG：表示该部分内容的标识，比如string数据是0x01，LOAD ClASS是0x02，栈帧Stack Frame是0x04</li>
<li>TIME：时间戳，作用不大，占4个字节，代码中也忽略不用</li>
<li>LENGTH：这个u4 field后面的，且属于这个rocord有意义的内容的长度，即body</li>
<li>BODY：该record所包含的对我们有意义的内容部分</li>
</ul>
<p>其中u1、u2、u4、u8后面的数字代表几个byte，比如u4就代表占用4个字节。</p>
<p>每一种record类型都对应着一个tag，目前支持的tag部分内容如下，具体参考<a href="http://hg.openjdk.java.net/jdk8/jdk8/jdk/raw-file/43cb25339b55/src/share/demo/jvmti/hprof/manual.html#mozTocId848088" target="_blank" rel="noopener">HPROF Agent</a> Binary Dump Format这一节：</p>
<p><img src="https://raw.githubusercontent.com/hningoba/KnowledgeSummary/master/img/matrix_hprof_tag.png" style="zoom:65%;"></p>
<p>比如string数据是0x01，LOAD ClASS是0x02，stack frame是0x04，stack trace是0x05等等。</p>
<h5 id="HAHA库解析Hprof"><a href="#HAHA库解析Hprof" class="headerlink" title="HAHA库解析Hprof"></a>HAHA库解析Hprof</h5><p>先看下HAHA库的解析逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">com.tencent.matrix.resource.analyzer.model.HeapSnapshot</span><br><span class="line"></span><br><span class="line">public class HeapSnapshot &#123;</span><br><span class="line"></span><br><span class="line">    private final File mHprofFile;</span><br><span class="line">    private final Snapshot mSnapshot;</span><br><span class="line"></span><br><span class="line">    public HeapSnapshot(File hprofFile) throws IOException &#123;</span><br><span class="line">        mHprofFile = checkNotNull(hprofFile, &quot;hprofFile&quot;);</span><br><span class="line">        //解析出SnapShot</span><br><span class="line">        mSnapshot = initSnapshot(hprofFile);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static Snapshot initSnapshot(File hprofFile) throws IOException &#123;</span><br><span class="line">        final HprofBuffer buffer = new MemoryMappedFileBuffer(hprofFile);</span><br><span class="line">        final HprofParser parser = new HprofParser(buffer);</span><br><span class="line">        //实际解析逻辑</span><br><span class="line">        final Snapshot result = parser.parse();</span><br><span class="line">        AnalyzeUtil.deduplicateGcRoots(result);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码重点在<code>HprofParser.parse()</code>，当前Matrix版本使用haha-2.0.3版本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">com.squareup.haha.perflib.HprofParser</span><br><span class="line"></span><br><span class="line">public final Snapshot parse() &#123;</span><br><span class="line">        Snapshot snapshot = new Snapshot(mInput);</span><br><span class="line">        mSnapshot = snapshot;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                readNullTerminatedString();  // Version, ignored for now.</span><br><span class="line"></span><br><span class="line">                mIdSize = mInput.readInt();	//解析ID长度，默认u4</span><br><span class="line">                mSnapshot.setIdSize(mIdSize);</span><br><span class="line"></span><br><span class="line">                mInput.readLong();  // Timestamp, ignored for now.</span><br><span class="line"></span><br><span class="line">                while (mInput.hasRemaining()) &#123;</span><br><span class="line">                    int tag = readUnsignedByte();	//解析TAG</span><br><span class="line">                    mInput.readInt(); // Ignored: timestamp，忽略时间戳</span><br><span class="line">                    long length = readUnsignedInt();	//解析LENGTH</span><br><span class="line"></span><br><span class="line">                    //根据tag及length，解析body</span><br><span class="line">                    switch (tag) &#123;</span><br><span class="line">                        case STRING_IN_UTF8:	// tag为0x01</span><br><span class="line">                            // String length is limited by Int.MAX_VALUE anyway.</span><br><span class="line">                            loadString((int) length - mIdSize);</span><br><span class="line">                            break;</span><br><span class="line"></span><br><span class="line">                        case LOAD_CLASS:	// tag为0x02</span><br><span class="line">                            loadClass();</span><br><span class="line">                            break;</span><br><span class="line"></span><br><span class="line">                        case STACK_FRAME:	// tag为0x04</span><br><span class="line">                            loadStackFrame();</span><br><span class="line">                            break;</span><br><span class="line"></span><br><span class="line">                        case STACK_TRACE:	// tag为0x06</span><br><span class="line">                            loadStackTrace();</span><br><span class="line">                            break;</span><br><span class="line"></span><br><span class="line">                        case HEAP_DUMP:	// tag为0x0C</span><br><span class="line">                            loadHeapDump(length);</span><br><span class="line">                            mSnapshot.setToDefaultHeap();</span><br><span class="line">                            break;</span><br><span class="line"></span><br><span class="line">                        case HEAP_DUMP_SEGMENT:	// tag为0x1C</span><br><span class="line">                            loadHeapDump(length);</span><br><span class="line">                            mSnapshot.setToDefaultHeap();</span><br><span class="line">                            break;</span><br><span class="line"></span><br><span class="line">                        default:</span><br><span class="line">                            skipFully(length);	// 跳过当前record</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (EOFException eof) &#123;</span><br><span class="line">                //  this is fine</span><br><span class="line">            &#125;</span><br><span class="line">            mSnapshot.resolveClasses();</span><br><span class="line">            mSnapshot.resolveReferences();</span><br><span class="line">            // TODO: enable this after the dominators computation is also optimized.</span><br><span class="line">            // mSnapshot.computeRetainedSizes();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mClassNames.clear();</span><br><span class="line">        mStrings.clear();</span><br><span class="line">        return snapshot;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上面<code>parse()</code>中的while循环，开始都会先读取TAG、TIME、LENGTH这三个部分的内容，然后再根据tag解析对应类型的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int tag = readUnsignedByte();</span><br><span class="line">mInput.readInt(); // Ignored: timestamp</span><br><span class="line">long length = readUnsignedInt();</span><br></pre></td></tr></table></figure>
<p>拿stack frame举例，看下解析逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">com.squareup.haha.perflib.HprofParser</span><br><span class="line"></span><br><span class="line">private void loadStackFrame() throws IOException &#123;</span><br><span class="line">        long id = readId();	//stack frame ID</span><br><span class="line">        String methodName = mStrings.get(readId());	//method name string ID</span><br><span class="line">        String methodSignature = mStrings.get(readId()); //method signature ID</span><br><span class="line">        String sourceFile = mStrings.get(readId()); // source file name ID</span><br><span class="line">        int serial = mInput.readInt();	// class serial number</span><br><span class="line">        int lineNumber = mInput.readInt();	// line number</span><br><span class="line"></span><br><span class="line">        StackFrame frame = new StackFrame(id, methodName, methodSignature,</span><br><span class="line">                sourceFile, serial, lineNumber);</span><br><span class="line"></span><br><span class="line">        mSnapshot.addStackFrame(frame);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上面每一行的内容和文档中对STACK FRAME的格式描述严格一致，所以，为什么说HAHA库是把Hprof这种文档描述结构转义成了引用关系结构，也是这个原因。</p>
<p>分析结果，ActivityLeakResult中referenceChain内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* GC ROOT android.os.HandlerThread contextClassLoader</span><br><span class="line">* references dalvik.system.PathClassLoader runtimeInternalObjects</span><br><span class="line">* references array java.lang.Object[] [412]</span><br><span class="line">* references static sample.tencent.matrix.resource.TestLeakActivity testLeaks</span><br><span class="line">* references java.util.HashSet map</span><br><span class="line">* references java.util.HashMap table</span><br><span class="line">* references array java.util.HashMap$Node[] [0]</span><br><span class="line">* references java.util.HashMap$Node key</span><br><span class="line">* leaks sample.tencent.matrix.resource.TestLeakActivity instance</span><br></pre></td></tr></table></figure>
<p>最后一行显示<code>sample.tencent.matrix.resource.TestLeakActivity</code>发生泄漏，从下到上是<code>TestLeakActivity</code>到GCRoots的强引用链。从第四行可以看到静态变量<code>testLeaks</code>，这个检测结果和开篇《如何判断Activity发生泄漏》中讲到静态变量<code>testLeaks</code>持有<code>TestLeakActivity</code>导致其无法释放的结论是一致的。</p>
<h3 id="如何检测重复Bitmap对象"><a href="#如何检测重复Bitmap对象" class="headerlink" title="如何检测重复Bitmap对象"></a>如何检测重复Bitmap对象</h3><p>这部分内容，实现思路wiki中的描述如下：原理简单粗暴——把所有未被回收的Bitmap的数据buffer取出来，然后先对比所有长度为1的buffer，找出相同的，记录所属的Bitmap对象；再对比所有长度为2的、长度为3的buffer……直到把所有buffer都比对完，这样就记录下了所有冗余的Bitmap对象了，接着再套用LeakCanary获取引用链的逻辑把这些Bitmap对象到GC Root的最短强引用链找出来即可。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://github.com/Tencent/matrix/wiki/Matrix-Android-ResourceCanary" target="_blank" rel="noopener">Matrix ResourceCanary Wiki</a></p>
<p><a href="http://hg.openjdk.java.net/jdk8/jdk8/jdk/raw-file/43cb25339b55/src/share/demo/jvmti/hprof/manual.html" target="_blank" rel="noopener">HPROF Agent</a></p>
<p><a href="https://developer.android.com/studio/profile/memory-profiler#save-hprof" target="_blank" rel="noopener">使用 Memory Profiler 查看 Java 堆和内存分配</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/04/28/Matrix概览/" rel="next" title="Matrix概览">
                <i class="fa fa-chevron-left"></i> Matrix概览
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">hningoba</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#如何判断Activity发生泄漏"><span class="nav-text">如何判断Activity发生泄漏</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#获取已销毁Activity的信息"><span class="nav-text">获取已销毁Activity的信息</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#如何判断Activity无法被GC回收"><span class="nav-text">如何判断Activity无法被GC回收</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hprof信息使用"><span class="nav-text">Hprof信息使用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#如何获取Hprof文件"><span class="nav-text">如何获取Hprof文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#如何获取引用链"><span class="nav-text">如何获取引用链</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Hprof文件分析"><span class="nav-text">Hprof文件分析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Hprof文件格式说明"><span class="nav-text">Hprof文件格式说明</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HAHA库解析Hprof"><span class="nav-text">HAHA库解析Hprof</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何检测重复Bitmap对象"><span class="nav-text">如何检测重复Bitmap对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参考"><span class="nav-text">参考</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hningoba</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
